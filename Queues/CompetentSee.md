Let's go!
Data CompetentSee said:

Great! What topic would you like to show competency in?

You said:
Queue
Data CompetentSee said:

In your editor, implement the following functional requirements for a **Queue** using the structure `{list, list}` (with one list for the front and another for the rear):

1. `empty(queue)`

   * **Input**: A queue.
   * **Output**: `true` if the queue is empty, `false` otherwise.

2. `enqueue(queue, element)`

   * **Input**: A queue and an element.
   * **Output**: A new queue with the element added to the rear.

3. `dequeue(queue)`

   * **Input**: A queue.
   * **Output**: A new queue with the first element removed.

4. `head(queue)`

   * **Input**: A queue.
   * **Output**: The first element or `nil` if the queue is empty.

5. `tail(queue)`

   * **Input**: A queue.
   * **Output**: The last element or `nil` if the queue is empty.

6. `toList(queue)`

   * **Input**: A queue.
   * **Output**: A list of elements in order.

7. `fromList(list)`

   * **Input**: A list of elements.
   * **Output**: A queue.

**Task Instructions**:

* Use functional programming principles.
* Write tests to validate each function.
* Ensure the queue adheres to FIFO behavior.
* Use recursive definitions wherever appropriate.
* Include tests for:

  * Enqueuing and dequeuing from an empty queue.
  * Accessing head and tail at various stages.
  * Converting between lists and queues.
  * Sequential combinations of enqueue and dequeue.

**Challenge Extension (Optional)**:

* Implement `reverse(queue)` to reverse the queue.
* Implement `length(queue)` to count the elements.

Please test your code to see if it works.

